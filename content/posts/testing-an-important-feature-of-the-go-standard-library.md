---
title: "Testing, an important feature of the Go standard library"
tags: [go-standard-library, "development", "golang", "testing"]
date: 2021-01-21T12:51:41+01:00
draft: false
images: ["assets/testing-an-important-feature-of-the-go-standard-library.png"]
description: "Have you always wanted to learn everything about testing with the Go standard library?  
I'll show you everything from the first test to parallelization."
toc: false
---

Testing should be a big part of our daily work routine as a software developer, which is the reason
for this article. During my last project I often had problems writing good and robust tests for Go, 
which now gives me the best basis for a new post. Fortunately, again the Go standard library 
provides a solution for testing: [pkg/testing](https://golang.org/pkg/testing/). Let's take a look 
at the library code together to better understand testing in Go. Maybe there is also 
something new for the more experienced Go developers that they didn't know yet.

{{< toc >}}

## A quick and short introduction to Go testing

This part is a brief overview over the basic functionality of testing in Go. You can skip this
section if simple tests are already a habit for you.

### Where should I place a Go test?

First, add the test file as close as possible to the code/ package it will test. Always name your 
test files the same as the file under test and attach "_test.go". Let's assume, the file under test 
is "validator.go", then name your test file "validator_test.go" and place it into the same 
directory. 

```bash
.
├── pkg
│   ├── validator.go
│   └── validator_test.go
```

### How do I write a Go test?

A test is nothing else then a function, and its name is prefixed with "Test", followed by the test 
description written in PascalCase for an automatic test execution on `go test` and in camelCase to 
avoid the automatic test execution. 

Test with automatic test execution on `go test`:
```golang
func TestValidateStringNotBlank(*testing.T)
```
```shell
$ go test
PASS
ok      github.com/lrotermund/testing/pkg/validation   0.003s
```

Test _without_ automatic test execution:
```golang
func TestvalidateStringNotBlank(*testing.T)
```
```shell
$ go test
ok      github.com/lrotermund/testing/pkg/validation   0.001s [no tests to run]
```

Both functions accepting a pointer of 
[testing.T](https://golang.org/src/testing/testing.go?s=23377:23479#L647), which is necessary to 
make the current test fail. But what does a test that integrates 
[testing.T](https://golang.org/src/testing/testing.go?s=23377:23479#L647) look like and how do I 
make a test fail?

```golang
func TestValidateStringNotBlank(t *testing.T) {
    s := buggyFuncReturningBlankStr()

    if len(s) == 0 {
		t.Log("String returned by buggyFuncReturningBlankStr() is blank")
        t.Fail()
    }
}

func buggyFuncReturningBlankStr() string {
    return ""
}
```
Let's take a look at what happens here in the test step by step. First, I added the parameter name 
"t" for the [testing.T](https://golang.org/src/testing/testing.go?s=23377:23479#L647) pointer. For a 
simple illustration, the test uses the intentionally buggy function `buggyFuncReturningBlankStr()`, 
which returns a blank string, causing `s` to contain also a blank string. 

Now to make sure our string is not blank, the test checks the length of `s` via `if len(s) == 0`. 
Since `s` was initialized blank by the `buggyFuncReturningBlankStr()` function, the log message 
"String returned by buggyFuncReturningBlankStr() is blank" is now generated by the 
[t.Log()](https://golang.org/src/testing/testing.go?s=27069:27110#L766) function and the test is 
marked as failed by [t.Fail()](https://golang.org/src/testing/testing.go?s=23815:23838#L670) – we'll 
look at how all this happens later.

It is important to note here that the test deliberately results in a failed test to illustrate the 
result of the [t.Log](https://golang.org/src/testing/testing.go?s=27069:27110#L766) and the 
[t.Fail()](https://golang.org/src/testing/testing.go?s=23815:23838#L670) function. Of course, the 
goal is always to have successful tests.

Now let's run the test via `go test` and see if we get our expected error message.
```shell
$ go test
--- FAIL: TestValidateStringNotBlank (0.00s)
    validator_test.go:9: String returned by buggyFuncReturningBlankStr() is blank
FAIL
exit status 1
FAIL    github.com/lrotermund/testing/pkg/validation   0.001s
```

Perfect, the expected error message was logged. There are many more ways to mark a test as failed 
and we will look at these in the next section.

## Mark a Go test as failed

Tests are marked as "passed" if they were not marked as failed during the test. There are several 
ways to mark a test as failed – let's dive into the Go standard library and start with the "Fail" 
function.

### Use the Fail function to mark a test as failed

```golang
func (c *common) Fail() {
	if c.parent != nil {
		c.parent.Fail()
	}
	c.mu.Lock()
	defer c.mu.Unlock()
	// c.done needs to be locked to synchronize checks to c.done in parent tests.
	if c.done {
		panic("Fail in goroutine after " + c.name + " has completed")
	}
	c.failed = true
}
```
(Source: [testing/testing.go](https://golang.org/src/testing/testing.go?s=23815:23838#L670))

Below you find the common struct used in `Fail()` so you have the fields and their types available 
for reference. (in a shortened form).

```golang
type common struct {
    ...
    mu     sync.RWMutex // guards this group of fields
	failed bool         // Test or benchmark has failed.
	done   bool         // Test is finished and all subtests have completed.
    parent *common
    name   string       // Name of test or benchmark.
    ...
}
```

(Source: [testing/testing.go](https://golang.org/src/testing/testing.go?s=14406:14426#L384))

Why do we have so many code in here for a simple fail function – why not just set failed to true? We 
can find the answer to this question already in the first few lines of Code, `if c.parent != nil` 
shows us that there could be a parent test that produced the current test and if so `Fail()` is also 
called on the parent test `c.parent.Fail()`.

Now its getting more complicated, what is this 
[sync.RWMutex](https://golang.org/src/sync/rwmutex.go?s=987:1319#L18) thats getting locked by 
`c.mu.Lock()`? In order to answer this question, we have to make a short excursion into the world of 
multi-threading in Go. 

We already know that there can be a parent test to our test and that already indicates the use of a 
[goroutine](https://tour.golang.org/concurrency/1). Before we clarify what a 
[sync.RWMutex](https://golang.org/src/sync/rwmutex.go?s=987:1319#L18) is, let's first look at a 
classic [sync.Mutex](https://golang.org/src/sync/mutex.go?s=765:813#L15). A 
{{< abbr "mutex" "mutual exclusion lock" >}} is your tool to protect a shared resource, like the 
common struct in our case, from race conditions due to an simultaneously read or write access. Let's 
have a brief look into the description of the `Lock()` function.

```golang
// Lock locks m.
// If the lock is already in use, the calling goroutine
// blocks until the mutex is available.
func (m *Mutex) Lock()
```
(Source: [sync/mutex.go](https://golang.org/src/sync/mutex.go?s=2534:2556#L62))

The description already brings it to the point – if the function `Lock()` of the mutex is called and 
this lock should already be set by another goroutine, our current goroutine is blocked until the 
lock is released again and this applies to reading, as well as writing accesses.

To take a less restrictive approach, a 
[sync.RWMutex](https://golang.org/src/sync/rwmutex.go?s=987:1319#L18) (reader/writer mutex) was 
integrated in the common struct. The 
[sync.RWMutex](https://golang.org/src/sync/rwmutex.go?s=987:1319#L18) slightly loosens the 
restriction that only one access can take place at the same time. Thus, it is possible that several 
read accesses, or one write access take place simultaneously on the shared resource. By the way, 
there are different lock functions for the different accesses: 
[Lock()](https://golang.org/src/sync/rwmutex.go?s=2805:2830#L82) and 
[RLock()](https://golang.org/src/sync/rwmutex.go?s=1558:1584#L33)

Now let's jump back into our `Fail()` function and to the next line of code `defer c.mu.Unlock()`. 
The `defer` statement causes the following instruction to be executed when the surrounding function 
returns, as a result we unlock the previously created lock at the end of the function with 
[Unlock()](https://golang.org/src/sync/rwmutex.go?s=3664:3691#L108) and release the resource again.

The next lines of code are a reaction to a race condition that occurs when the user has not 
synchronized his sub-tests/ goroutines appropriately and the test function completes successfully 
even though sub-tests are still running.

```golang
// c.done needs to be locked to synchronize checks to c.done in parent tests.
if c.done {
    panic("Fail in goroutine after " + c.name + " has completed")
}
```

Finally, the test is marked as failed via `c.failed = true`. Important to know: the test is __not 
aborted__ at this point. To abort a test completely in case of an error, the function 
[FailNow()](https://golang.org/src/testing/testing.go?s=24706:24732#L699) can be used, which we'll 
look in the next section – but first, an example of what I meant by "not aborted":

```golang
func TestMultipleAssertions(t *testing.T) {
	s := buggyFuncReturningNil()

	if s == nil {
		t.Log("assertion failed, expected a value, got nil")
		t.Fail()
	}

	if len(*s) == 0 {
		t.Log("assertion failed, expected a value, got blank string")
		t.Fail()
	}
}

func buggyFuncReturningNil() *string {
	return nil
}
```

Let's jump straight to the test execution and see what happens.

```shell
$ go test                                                                                           
--- FAIL: TestMultipleAssertions (0.00s)
    multipleassertions_test.go:9: assertion failed, expected a value, got nil
panic: runtime error: invalid memory address or nil pointer dereference [recovered]
        panic: runtime error: invalid memory address or nil pointer dereference
```

Oh no, we have a null pointer exception. The error message shows that the first assertion was 
successful and we also find the expected log message. The error occurs because the assertions are 
based on each other and the next assertion expects that the value can be dereferenced. If you 
want to cover this case, then you should use 
[FailNow()](https://golang.org/src/testing/testing.go?s=24706:24732#L699) as already mentioned.

Let's take another look at an example where multiple test cases are tested sequentially using the 
[t.Run()](https://golang.org/src/testing/testing.go?s=37631:37678#L1125) function with different 
parameters.

```golang
func TestWithSubTests(t *testing.T) {
	testCases := []struct {
		foo string
		bar string
	}{
		{"foo", "bar"},
		{"foo", ""},
		{"", "bar"},
		{"bar", "foo"},
	}

	for _, tc := range testCases {
		t.Run(fmt.Sprintf("%s-%s", tc.foo, tc.bar), func(t *testing.T) {
			s := buggyFuncCouldReturnBlankString(tc.foo, tc.bar)

			if len(s) == 0 {
				t.Fail()
			}
		})
	}
}

func buggyFuncCouldReturnBlankString(foo, bar string) (s string) {
	if len(foo) == 0 || len(bar) == 0 {
		return
	}

	s = fmt.Sprintf("%s::%s", foo, bar)
	return
}
```

This is a common pattern in Go testing to test a bunch of test cases against a function. First, you
declare your test cases within a slice. Then you loop over these test cases and start a sub-test 
with [t.Run()](https://golang.org/src/testing/testing.go?s=37631:37678#L1125). The first parameter
is the name of the sub-test and the second one is the sub-test function. 

Let's run the test with `go test`:

```shell
$ go test                                                                                        
--- FAIL: TestWithSubTests (0.00s)
    --- FAIL: TestWithSubTests/foo- (0.00s)
    --- FAIL: TestWithSubTests/-bar (0.00s)
FAIL
exit status 1
FAIL    github.com/lrotermund/testing/pkg/subtests   0.001s
```

Here you can see very nicely how `go test` displays the failed sub-tests indented, which quickly 
shows which of the sub-tests failed and which parameter combinations did not work.

### Stop test execution directly with the FailNow function

Let's have a look at the [FailNow()](https://golang.org/src/testing/testing.go?s=24706:24732#L699) 
code before we jump into an example.

```golang
func (c *common) FailNow() {
	c.Fail()

	// Calling runtime.Goexit will exit the goroutine, which
	// will run the deferred functions in this goroutine,
	// which will eventually run the deferred lines in tRunner,
	// which will signal to the test loop that this test is done.
	//
	// A previous version of this code said:
	//
	//	c.duration = ...
	//	c.signal <- c.self
	//	runtime.Goexit()
	//
	// This previous version duplicated code (those lines are in
	// tRunner no matter what), but worse the goroutine teardown
	// implicit in runtime.Goexit was not guaranteed to complete
	// before the test exited. If a test deferred an important cleanup
	// function (like removing temporary files), there was no guarantee
	// it would run on a test failure. Because we send on c.signal during
	// a top-of-stack deferred function now, we know that the send
	// only happens after any other stacked defers have completed.
	c.finished = true
	runtime.Goexit()
}
```

(Source: [testing/testing.go](https://golang.org/src/testing/testing.go?s=24706:24732#L699))

[FailNow()](https://golang.org/src/testing/testing.go?s=24706:24732#L699) first executes 
[Fail()](https://golang.org/src/testing/testing.go?s=23815:23838#L670) to mark the test as failed. 
You can read more about this in the previous section 
[Mark a Go test as failed](#mark-a-go-test-as-failed). Finally, the test is marked as "finished" and 
the current goroutine is terminated via `runtime.Goexit()`. Exiting the goroutine will execute the 
next test or benchmark.

Now let's pick up the previous example and replace the 
[Fail()](https://golang.org/src/testing/testing.go?s=23815:23838#L670) function with the 
[FailNow()](https://golang.org/src/testing/testing.go?s=24706:24732#L699) function and look at the 
output of `go test`.

```golang
func TestMultipleAssertionsWithFailNow(t *testing.T) {
	s := buggyFuncReturningNil()

	if s == nil {
		t.Log("assertion failed, expected a value, got nil")
		t.FailNow()
	}

	if len(*s) == 0 {
		t.Log("assertion failed, expected a value, got blank string")
		t.FailNow()
	}
}

func buggyFuncReturningNil() *string {
	return nil
}
```
```shell
$ go test
--- FAIL: TestMultipleAssertionsWithFailNow (0.00s)
    multiplefailnowassertions_test.go:9: assertion failed, expected a value, got nil
FAIL
exit status 1
FAIL    github.com/lrotermund/testing/pkg/failnow   0.004s
```

This time we were more lucky and our tests could be executed without an unexpected exception. The 
test was successfully terminated on the first call to 
[FailNow()](https://golang.org/src/testing/testing.go?s=24706:24732#L699).

### Simplified logging when marking a test as failed with the Error/ Errorf function

In the previous examples, I often printed the error messages of the Go tests via the 
[t.Log()](https://golang.org/src/testing/testing.go?s=27069:27110#L766) 
function and subsequently marked the test as failed via 
[t.Fail()](https://golang.org/src/testing/testing.go?s=23815:23838#L670) - fortunately, the Go 
standard library provides a way to avoid this boilerplate code: 
[t.Error()](https://golang.org/src/testing/testing.go?s=27660:27703#L776) and 
[t.Errorf()](https://golang.org/src/testing/testing.go?s=27799:27858#L782)

Let's take a look at the code.

```golang
func (c *common) Error(args ...interface{}) {
	c.log(fmt.Sprintln(args...))
	c.Fail()
}
```

(Source: [testing/testing.go](https://golang.org/src/testing/testing.go?s=27660:27703#L776))

As you can see, nothing really happens here except that the passed arguments are logged and then 
[Fail()](https://golang.org/src/testing/testing.go?s=23815:23838#L670) is called. The functionality 
of Fail was explained in the previous section 
[Use the Fail function to mark a test as failed](#use-the-fail-function-to-mark-a-test-as-failed).
Now let's replace 
[Log()](https://golang.org/src/testing/testing.go?s=27069:27110#L766) and 
[Fail()](https://golang.org/src/testing/testing.go?s=23815:23838#L670) with
[Error()](https://golang.org/src/testing/testing.go?s=27660:27703#L776) in our first example.

```golang
func TestValidateStringNotBlank(t *testing.T) {
    s := buggyFuncReturningBlankStr()

    if len(s) == 0 {
		t.Error("String returned by buggyFuncReturningBlankStr() is blank")
    }
}

func buggyFuncReturningBlankStr() string {
    return ""
}
```
```shell
$ go test
--- FAIL: TestValidateStringNotBlank (0.00s)
    validatorwitherror_test.go:9: String returned by buggyFuncReturningBlankStr() is blank
FAIL
exit status 1
FAIL    github.com/lrotermund/testing/pkg/validationwitherror   0.001s
```

Now let's look at [Errorf()](https://golang.org/src/testing/testing.go?s=27799:27858#L782) which 
calls the [c.log()](https://golang.org/src/testing/testing.go?s=25730:25763#L736) function with a 
formatted string to output the passed arguments in the specified formatting.

```golang
func (c *common) Errorf(format string, args ...interface{}) {
	c.log(fmt.Sprintf(format, args...))
	c.Fail()
}
```

(Source: [testing/testing.go](https://golang.org/src/testing/testing.go?s=27799:27858#L782))

Let's look at an example of how 
[Errorf()](https://golang.org/src/testing/testing.go?s=27799:27858#L782) can be used.

```golang
func TestPrintingFormattedError(t *testing.T) {
    input := "foobar"
    expected := "barfoo"

    s := buggyFuncReturningWrongStr(input)

    if s != expected {
		t.Errorf("assertion failed, expected %s, got %s", expected, s)
    }
}

func buggyFuncReturningWrongStr(s string) string {
    return "abcde"
}
```
```shell
$ go test
--- FAIL: TestPrintingFormattedError (0.00s)
    validatorwitherrorf_test.go:12: assertion failed, expected barfoo, got abcde
FAIL
exit status 1
FAIL    github.com/lrotermund/testing/pkg/validationwitherrorf   0.001s
```

### Simplified logging when stopping test execution directly with the Fatal/ Fatalf function

As with [Error()](https://golang.org/src/testing/testing.go?s=27660:27703#L776) and 
[Errorf()](https://golang.org/src/testing/testing.go?s=27799:27858#L782), 
[Fatal()](https://golang.org/src/testing/testing.go?s=27962:28005#L788) and 
[Fatalf()](https://golang.org/src/testing/testing.go?s=28107:28166#L794) are used to avoid boilerplate 
code by logging a desired value and then terminating the test directly via 
[FailNow()](https://golang.org/src/testing/testing.go?s=24706:24732#L699). The functionality of 
FailNow has already been explained in the previous section 
[Stop test execution directly with the FailNow function](#stop-test-execution-directly-with-the-failnow-function). Let's take a look at the code of the two functions before we implement them in an example.

```golang
// Fatal is equivalent to Log followed by FailNow.
func (c *common) Fatal(args ...interface{}) {
	c.log(fmt.Sprintln(args...))
	c.FailNow()
}

// Fatalf is equivalent to Logf followed by FailNow.
func (c *common) Fatalf(format string, args ...interface{}) {
	c.log(fmt.Sprintf(format, args...))
	c.FailNow()
}
```

(Source: [testing/testing.go](https://golang.org/src/testing/testing.go?s=27910:28220#L797))

As already mentioned, logging or formatted logging is done here via 
[c.log()](https://golang.org/src/testing/testing.go?s=25730:25763#L736) and the call to 
[FailNow()](https://golang.org/src/testing/testing.go?s=24706:24732#L699) follows afterwards. Let's 
jump now to an example where both functions are included.

```golang
func TestWithFatalInSubTests(t *testing.T) {
	testCases := []struct {
		foo string
		bar string
	}{
		{"foo", "bar"},
		{"foo", "foo"},
		{"bar", "bar"},
		{"bar", "foo"},
	}

	for _, tc := range testCases {
		t.Run(fmt.Sprintf("%s,%s", tc.foo, tc.bar), func(t *testing.T) {
			expected := fmt.Sprintf("%s::%s", tc.bar, tc.foo)
			s := buggyFuncCouldReturnBlankOrWrongString(tc.foo, tc.bar)

			if len(s) == 0 {
				t.Fatal("assertion failed, returned string is blank")
			}

			if s != expected {
				t.Fatalf("assertion failed, expected %s, got %s", expected, s)
			}
		})
	}
}

func buggyFuncCouldReturnBlankOrWrongString(foo, bar string) (s string) {
	if foo == "foo" && bar == "foo" {
		return
	}

	if foo == "bar" && bar == "bar" {
		return "foo::foo"
	}

	s = fmt.Sprintf("%s::%s", bar, foo)
	return
}
```

Let's see what is logged by [Fatal()](https://golang.org/src/testing/testing.go?s=27962:28005#L788) 
and [Fatalf()](https://golang.org/src/testing/testing.go?s=28107:28166#L794).

```shell
$ go test
--- FAIL: TestWithFatalInSubTests (0.00s)
    --- FAIL: TestWithFatalInSubTests/foo,foo (0.00s)
        subtestswithfatal_test.go:25: assertion failed, returned string is blank
    --- FAIL: TestWithFatalInSubTests/bar,bar (0.00s)
        subtestswithfatal_test.go:29: assertion failed, expected bar::bar, got foo::foo
FAIL
exit status 1
Fail    github.com/lrotermund/testing/pkg/subtestswithfatal   0.001s
```

## Run time-consuming test cases in parallel

It may well happen that the execution time of a test is unusually long. If several parameter 
combinations are now tested within this scenario, the execution time of all test cases can reach a 
disproportionate length. In the worst case, these above-average execution times can also exhaust the
time contingent of a CI/CP pipeline.

Let's look at an example where we have an unusually long execution time of a test.

```golang
func TestTimeConsumingSubTests(t *testing.T) {
	testCases := []string{
		"foo",
		"foobar",
		"foobarfoo",
		"foobarfoobar",
		"foobarfoobarfoo",
	}

	for _, tc := range testCases {
		t.Run(tc, func(t *testing.T) {
			timeConsumingOperation(tc)
		})
	}
}

func timeConsumingOperation(foo string) {
	sec := len(foo)
	time.Sleep(time.Duration(sec) * time.Second)
}
```
```shell
$ go test
PASS
ok      github.com/lrotermund/testing/pkg/notparallel   45.004s
```

In the `go test` output you can see that there is an execution time of 45 seconds and that is 
clearly too long. The Go standard library helps out again by providing the possibility to 
execute sub-tests in parallel in own goroutines via 
[t.Parallel()](https://golang.org/src/testing/testing.go?s=32974:32996#L969). Let's jump right into 
the code again – unlike the last functions for simplified logging, exciting code is waiting for us 
again.

```golang
func (t *T) Parallel() {
	if t.isParallel {
		panic("testing: t.Parallel called multiple times")
	}
	t.isParallel = true

	// We don't want to include the time we spend waiting for serial tests
	// in the test duration. Record the elapsed time thus far and reset the
	// timer afterwards.
	t.duration += time.Since(t.start)

	// Add to the list of tests to be released by the parent.
	t.parent.sub = append(t.parent.sub, t)
	t.raceErrors += race.Errors()

	if t.chatty != nil {
		// Unfortunately, even though PAUSE indicates that the named test is *no
		// longer* running, cmd/test2json interprets it as changing the active test
		// for the purpose of log parsing. We could fix cmd/test2json, but that
		// won't fix existing deployments of third-party tools that already shell
		// out to older builds of cmd/test2json — so merely fixing cmd/test2json
		// isn't enough for now.
		t.chatty.Updatef(t.name, "=== PAUSE %s\n", t.name)
	}

	t.signal <- true   // Release calling test.
	<-t.parent.barrier // Wait for the parent test to complete.
	t.context.waitParallel()

	if t.chatty != nil {
		t.chatty.Updatef(t.name, "=== CONT  %s\n", t.name)
	}

	t.start = time.Now()
	t.raceErrors += -race.Errors()
}
```

(Source: [testing/testing.go](https://golang.org/src/testing/testing.go?s=32974:32996#L969))

The first few lines of the function are a simple protection against multiple calls of 
[t.Parallel()](https://golang.org/src/testing/testing.go?s=32974:32996#L969). 

After that, the duration of the test is recorded up to the current time. The reason for this is that 
the sub-tests running in parallel are all registered first and then wait paused until the processing 
of the parallel tests starts. The time from here until the moment when the current test is started 
again is not included in the test duration - more about this later.

In order for our parallel test to be executed, it is next added to the parent test as a sub-test. To 
do this, it is simply appended to the sub slice.

At first, the next code confused me a bit. What is behind these "raceErrors" in 
`t.raceErrors += race.Errors()`? It is already clear from the field description that this is a 
mechanism for detecting race conditions. Let's jump into the used function `race.Error()` and see 
what is returned there.

```golang
func Errors() int { return 0 }
```

(Source: [internal/race/norace.go](https://golang.org/src/internal/race/norace.go?s=571:588#L32))

Zero? It just returns zero? Ok, the file name "norace.go" suggests a default case, but where does 
the use of this file come from - we don't initialize "race". So let's have a look at the all files 
used by [internal/race package](https://golang.org/src/internal/race/), maybe we can find more 
answers there.

```bash
.
├── internal/race
│   ├── doc.go
│   ├── norace.go
│   └── race.go
```

(Source: [internal/race](https://golang.org/src/internal/race/))

First, let's take a look at the documentation.

```golang
/*
Package race contains helper functions for manually instrumenting code for the race detector.

The runtime package intentionally exports these functions only in the race build;
this package exports them unconditionally but without the "race" build tag they are no-ops.
*/
package race
```

(Source: [internal/race/doc.go](https://golang.org/src/internal/race/doc.go))

According to the documentation, the features are only provided in the race build. After a short 
search for the mentioned "race" build tag, I came across the 
[build package](https://golang.org/pkg/go/build/) and the 
[build constraints](https://golang.org/pkg/go/build/#hdr-Build_Constraints). If we now take a look 
at the build tags/build constraints of "norace.go", as well as "race.go", we notice that depending 
on the tag, only one of the two files is used during the build. In the [introduction of the "Go Race 
Detector"](https://blog.golang.org/race-detector) it is also pointed out that the "-race" flag 
activates the race detection during the build.

```golang
// +build !race

package race
```
(Source: [internal/race/norace.go](https://golang.org/src/internal/race/norace.go?s=160:175))

```golang
// +build race

package race
```
(Source: [internal/race/race.go](https://golang.org/src/internal/race/race.go?s=160:175))

To complete the short journey through the Go standard library, this is the 
[Errors()](https://golang.org/src/internal/race/race.go?s=829:879#L52) function from the 
"race.go":

```golang
func Errors() int {
	return runtime.RaceErrors()
}
```

(Source: [internal/race/race.go](https://golang.org/src/internal/race/race.go?s=829:879#L52))

More complicated, deeper things happen here that even give different results depending on the 
operating system. If you want to know more and have some experience in C, you are welcome to dive 
deeper into the runtime – and if you find out more about it, feel free to let me know, I'm looking 
forward to an answer!

But now back to our [Parallel()](https://golang.org/src/testing/testing.go?s=32974:32996#L969) 
function. Since we build the tests without the "-race" flag, `t.raceErrors` is simply initialized 
with 0, or incremented by 0, so we can safely ignore this line of code. Let's move on!

Next comes the check to see if `t.chatty` is nil. `t.chatty` is the pointer of a chattyPrinter and 
we initialize it when we start `go test` with the verbose flag "-v". Via 
`t.chatty.Updatef(t.name, "=== PAUSE %s\n", t.name)` there is now a logging that the sub-test is now 
in pause mode.

After chatty-logging there are two lines of code that exchange signals between goroutines. 

```golang
t.signal <- true   // Release calling test.
<-t.parent.barrier // Wait for the parent test to complete.
```

(Source: [testing/testing.go](https://golang.org/src/testing/testing.go?s=32974:32996#L969))

If you haven't had any contact with goroutines yet, I generally recommend you to work through the 
[concurrency tour by golang](https://tour.golang.org/concurrency/1). Goroutines are a special kind 
of multi-threading which is not done by the operating system but by Go. A goroutine needs less 
resources than a thread of the operating system and Go can manage thousands of goroutines at the 
same time - but whether they actually run in parallel depends on the host system. You will learn 
more about this in the [tour](https://tour.golang.org/concurrency/1).

The lines of code we came across in the 
[Parallel()](https://golang.org/src/testing/testing.go?s=32974:32996#L969) function deal with the 
exchange of signals between different goroutines. This signal exchange is done via so-called 
channels. On these channels it is possible to send and receive bidirectional, to send only, or to 
receive only.

The first signal transmission `t.signal <- true` sends a signal, in this case the Boolean value 
"true", into the channel `t.signal`. The calling test is already waiting for this signal to complete 
the initialization of this parallel test. We'll take a look at how this is expressed in the verbose 
mode of test execution in a moment. First, let's look at where the calling test waits for the 
signal.  

```golang {hl_lines=[34,35]}
func (t *T) Run(name string, f func(t *T)) bool {
	atomic.StoreInt32(&t.hasSub, 1)
	testName, ok, _ := t.context.match.fullName(&t.common, name)
	if !ok || shouldFailFast() {
		return true
	}
	// Record the stack trace at the point of this call so that if the subtest
	// function - which runs in a separate stack - is marked as a helper, we can
	// continue walking the stack into the parent test.
	var pc [maxStackLen]uintptr
	n := runtime.Callers(2, pc[:])
	t = &T{
		common: common{
			barrier: make(chan bool),
			signal:  make(chan bool),
			name:    testName,
			parent:  &t.common,
			level:   t.level + 1,
			creator: pc[:n],
			chatty:  t.chatty,
		},
		context: t.context,
	}
	t.w = indenter{&t.common}

	if t.chatty != nil {
		t.chatty.Updatef(t.name, "=== RUN   %s\n", t.name)
	}
	// Instead of reducing the running count of this test before calling the
	// tRunner and increasing it afterwards, we rely on tRunner keeping the
	// count correct. This ensures that a sequence of sequential tests runs
	// without being preempted, even when their parent is a parallel test. This
	// may especially reduce surprises if *parallel == 1.
	go tRunner(t, f)
	if !<-t.signal {
		// At this point, it is likely that FailNow was called on one of the
		// parent tests by one of the subtests. Continue aborting up the chain.
		runtime.Goexit()
	}
	return !t.failed
}
```

(Source: [testing/testing.go](https://golang.org/src/testing/testing.go?s=37631:37678#L1125))

Each of our sub-tests is started via 
[t.Run()](https://golang.org/src/testing/testing.go?s=37631:37678#L1125) and passed to its own 
goroutine via `go tRunner(t, f)`. After passing, 
[t.Run()](https://golang.org/src/testing/testing.go?s=37631:37678#L1125) waits for a signal in the 
`t.signal` channel, which is either sent by `tRunner` when a test finishes or by the 
[Parallel()](https://golang.org/src/testing/testing.go?s=32974:32996#L969) function to release the 
calling test. Since the latter is the case and `t.failed` has not yet been set and is therefore 
"false", [t.Run()](https://golang.org/src/testing/testing.go?s=37631:37678#L1125) passes 
successfully and the next sub-test will be initialized by the calling test.

Next, we look at the receiving channel `t.parent.barrier`. At this point, the code is waiting for a 
signal to be sent to this channel. Waiting for a signal blocks the goroutine and thus the sub-test 
is blocked. But why is test execution blocked and when will execution resume?

The execution is blocked so that all previously initialized tests can be started and processed in 
parallel after the calling test is completed. Now let's see where the signal comes from that allows 
the execution of the sub-tests to continue again.

```golang {hl_lines=[56,61]}
func tRunner(t *T, fn func(t *T)) {
	t.runner = callerName(0)

	// When this goroutine is done, either because fn(t)
	// returned normally or because a test failure triggered
	// a call to runtime.Goexit, record the duration and send
	// a signal saying that the test is done.
	defer func() {
		if t.Failed() {
			atomic.AddUint32(&numFailed, 1)
		}

		if t.raceErrors+race.Errors() > 0 {
			t.Errorf("race detected during execution of test")
		}

		// If the test panicked, print any test output before dying.
		err := recover()
		signal := true
		if !t.finished && err == nil {
			err = errNilPanicOrGoexit
			for p := t.parent; p != nil; p = p.parent {
				if p.finished {
					t.Errorf("%v: subtest may have called FailNow on a parent test", err)
					err = nil
					signal = false
					break
				}
			}
		}

		doPanic := func(err interface{}) {
			t.Fail()
			if r := t.runCleanup(recoverAndReturnPanic); r != nil {
				t.Logf("cleanup panicked with %v", r)
			}
			// Flush the output log up to the root before dying.
			for root := &t.common; root.parent != nil; root = root.parent {
				root.mu.Lock()
				root.duration += time.Since(root.start)
				d := root.duration
				root.mu.Unlock()
				root.flushToParent(root.name, "--- FAIL: %s (%s)\n", root.name, fmtDuration(d))
				if r := root.parent.runCleanup(recoverAndReturnPanic); r != nil {
					fmt.Fprintf(root.parent.w, "cleanup panicked with %v", r)
				}
			}
			panic(err)
		}
		if err != nil {
			doPanic(err)
		}

		t.duration += time.Since(t.start)

		if len(t.sub) > 0 {
			// Run parallel subtests.
			// Decrease the running count for this test.
			t.context.release()
			// Release the parallel subtests.
			close(t.barrier)
			// Wait for subtests to complete.
			for _, sub := range t.sub {
				<-sub.signal
			}
			cleanupStart := time.Now()
			err := t.runCleanup(recoverAndReturnPanic)
			t.duration += time.Since(cleanupStart)
			if err != nil {
				doPanic(err)
			}
			if !t.isParallel {
				// Reacquire the count for sequential tests. See comment in Run.
				t.context.waitParallel()
			}
		} else if t.isParallel {
			// Only release the count for this test if it was run as a parallel
			// test. See comment in Run method.
			t.context.release()
		}
		t.report() // Report after all subtests have finished.

		// Do not lock t.done to allow race detector to detect race in case
		// the user does not appropriately synchronizes a goroutine.
		t.done = true
		if t.parent != nil && atomic.LoadInt32(&t.hasSub) == 0 {
			t.setRan()
		}
		t.signal <- signal
	}()
	defer func() {
		if len(t.sub) == 0 {
			t.runCleanup(normalPanic)
		}
	}()

	t.start = time.Now()
	t.raceErrors = -race.Errors()
	fn(t)

	// code beyond here will not be executed when FailNow is invoked
	t.finished = true
}
```

(Source: [testing/testing.go](https://golang.org/src/testing/testing.go?s=34467:34503#L1020))

In the [tRunner()](https://golang.org/src/testing/testing.go?s=34467:34503#L1020) function a lot of 
things happen, which I will not go into detail here. If you ignore the deferred functions, basically 
only the passed test is started. Most of the magic happens in the last deferred function of the 
[LIFO stack](https://de.wikipedia.org/wiki/Last_In_%E2%80%93_First_Out "Last In – First Out"). Since 
we added several sub-tests during the test, `len(t.sub)` is greater than zero in any case, which 
causes the `t.barrier` channel to be closed by `close(t.barrier)`. After that, all subtests are 
iterated through until it is ensured that they have all been processed. 

Let's leave the [tRunner()](https://golang.org/src/testing/testing.go?s=34467:34503#L1020) function 
behind for now and take a look at the next code of the 
[Parallel()](https://golang.org/src/testing/testing.go?s=32974:32996#L969) function.

The `t.context.waitParallel()` function ensures that the number of tests currently running does not 
exceed the maximum number of parallel tests. If this is the case, the test is paused again until a 
corresponding signal is received in the `c.startParallel` channel.


```golang
func (c *testContext) waitParallel() {
	c.mu.Lock()
	if c.running < c.maxParallel {
		c.running++
		c.mu.Unlock()
		return
	}
	c.numWaiting++
	c.mu.Unlock()
	<-c.startParallel
}
```

(Source: [testing/testing.go](https://golang.org/src/testing/testing.go?s=40201:40240#L1211))

At the end of the [Parallel()](https://golang.org/src/testing/testing.go?s=32974:32996#L969) 
function, a verbose mode chatty logging is performed informing that the sub-test is now resuming, 
also the start time of the test is changed to now and the `t.raceErrors` are reduced again, in our 
case by zero since we did not start the test with the "-race" flag.

Let's now run our tests from the beginning in parallel mode.

```golang {hl_lines=[11,14]}
func TestParallelTimeConsumingSubTests(t *testing.T) {
	testCases := []string{
		"foo",
		"foobar",
		"foobarfoo",
		"foobarfoobar",
		"foobarfoobarfoo",
	}

	for _, tc := range testCases {
        tc := tc
        
		t.Run(tc, func(t *testing.T) {
			t.Parallel()
			timeConsumingOperation(tc)
		})
	}
}

func timeConsumingOperation(foo string) {
	sec := len(foo)
	time.Sleep(time.Duration(sec) * time.Second)
}
```
```shell
$ go test
PASS
ok      github.com/lrotermund/testing/pkg/parallel   15.003s
```

Woohoo! We saved 30 seconds of execution time using the 
[Parallel()](https://golang.org/src/testing/testing.go?s=32974:32996#L969) function. Two things have 
been added to the test, firstly a copy of `tc` so that the correct value is used in the sub-test 
when it is executed later and secondly the 
[Parallel()](https://golang.org/src/testing/testing.go?s=32974:32996#L969) function was called at 
the beginning of the sub-test. 

Now let's add some logging and look at the execution order.

```golang
func TestParallelTimeConsumingSubTests(t *testing.T) {
	testCases := []string{
		"foo",
		"foobar",
		"foobarfoo",
		"foobarfoobar",
		"foobarfoobarfoo",
    }
    
	fmt.Println("\n\t... START TC INIT")

	for _, tc := range testCases {
		tc := tc
		start := time.Now()

		t.Run(tc, func(t *testing.T) {
			fmt.Printf("\t... INIT TC: %s (%s)\n", tc, time.Since(start))

			t.Parallel()

			fmt.Printf("\t... START TC: %s (%s)\n", tc, time.Since(start))
			timeConsumingOperation(tc)
			fmt.Printf("\t... FINISHED TC: %s (%s)\n", tc, time.Since(start))
		})

		fmt.Printf("\t... FINISHED TC INIT: %s (%s)\n", tc, time.Since(start))
	}

	fmt.Printf("\n\t... FINISHED CALLING TEST\n\n")
}
```
```shell
$ go test -v
=== RUN   TestParallelTimeConsumingSubTests

        ... START TC INIT
=== RUN   TestParallelTimeConsumingSubTests/foo
        ... INIT TC: foo (34.427µs)
=== PAUSE TestParallelTimeConsumingSubTests/foo
        ... FINISHED TC INIT: foo (76.882µs)
=== RUN   TestParallelTimeConsumingSubTests/foobar
        ... INIT TC: foobar (26.382µs)
=== PAUSE TestParallelTimeConsumingSubTests/foobar
        ... FINISHED TC INIT: foobar (57.325µs)
=== RUN   TestParallelTimeConsumingSubTests/foobarfoo
        ... INIT TC: foobarfoo (22.079µs)
=== PAUSE TestParallelTimeConsumingSubTests/foobarfoo
        ... FINISHED TC INIT: foobarfoo (54.013µs)
=== RUN   TestParallelTimeConsumingSubTests/foobarfoobar
        ... INIT TC: foobarfoobar (24.335µs)
=== PAUSE TestParallelTimeConsumingSubTests/foobarfoobar
        ... FINISHED TC INIT: foobarfoobar (52.606µs)
=== RUN   TestParallelTimeConsumingSubTests/foobarfoobarfoo
        ... INIT TC: foobarfoobarfoo (31.238µs)
=== PAUSE TestParallelTimeConsumingSubTests/foobarfoobarfoo
        ... FINISHED TC INIT: foobarfoobarfoo (64.466µs)

        ... FINISHED CALLING TEST

=== CONT  TestParallelTimeConsumingSubTests/foo
        ... START TC: foo (363.31µs)
=== CONT  TestParallelTimeConsumingSubTests/foobarfoobar
        ... START TC: foobarfoobar (216.193µs)
=== CONT  TestParallelTimeConsumingSubTests/foobarfoo
        ... START TC: foobarfoo (325.005µs)
=== CONT  TestParallelTimeConsumingSubTests/foobar
        ... START TC: foobar (401.475µs)
=== CONT  TestParallelTimeConsumingSubTests/foobarfoobarfoo
        ... START TC: foobarfoobarfoo (240.937µs)
        ... FINISHED TC: foo (3.000699096s)
        ... FINISHED TC: foobar (6.000655952s)
        ... FINISHED TC: foobarfoo (9.000769753s)
        ... FINISHED TC: foobarfoobar (12.000636504s)
        ... FINISHED TC: foobarfoobarfoo (15.000596721s)
--- PASS: TestParallelTimeConsumingSubTests (0.00s)
    --- PASS: TestParallelTimeConsumingSubTests/foo (3.00s)
    --- PASS: TestParallelTimeConsumingSubTests/foobar (6.00s)
    --- PASS: TestParallelTimeConsumingSubTests/foobarfoo (9.00s)
    --- PASS: TestParallelTimeConsumingSubTests/foobarfoobar (12.00s)
    --- PASS: TestParallelTimeConsumingSubTests/foobarfoobarfoo (15.00s)
PASS
ok      github.com/lrotermund/testing/pkg/parallelverbose   15.004s
```

The console output coincides with our code analysis. First, all test cases are initialized and their 
execution is paused. Then, the calling test is terminated and parallel sub-test execution is 
resumed.

## Conclusion

Testing is an essential part of software development and every developer should be encouraged to 
integrate testing into their daily work. The [testing package](https://golang.org/pkg/testing/) is 
extremely well done and provides a clean foundation for easy integration of testing into the 
development workflow.

Especially the approach of running multiple test cases as sub-tests in parallel, thus saving 
execution time and logically grouping the test code, really excited me.

I hope you were able to learn something new and also had fun taking a closer look at the 
[testing package](https://golang.org/pkg/testing/). If you feel like discussing the article with me, 
or if you just have some comments, feel free to contact me on 
[Linkedin](https://www.linkedin.com/in/lukas-rotermund) or 
[Xing](https://www.xing.com/profile/Lukas_Rotermund2).